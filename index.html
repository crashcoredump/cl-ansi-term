<!doctype html>
<html lang="en">
  <!--
  Documentation for cl-ansi-term - library to output primitives on
  ANSI-complaint terminals.

  Copyright (c) 2015 Mark Karpov

  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.3 or any
  later version published by the Free Software Foundation; with no Invariant
  Sections, no Front-Cover Texts, and no Back-Cover Texts.  A copy of the
  license is included in the section entitled "GNU Free Documentation
  License".  -->
  <head>
    <meta charset="utf-8">
    <meta name="description"    content="cl-ansi-term documentation">
    <meta name="author"         content="Mark Karpov">
    <meta name="dcterms.rights" content="(c) 2015 Mark Karpov">
    <meta name="keywords"       content="ANSI terminal, escape sequence">
    <title>cl-ansi-term</title>
    <link href="ascetic.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <h1>cl-ansi-term</h1>
    <h2 id="0">Table of Contents</h2>
    <ul class="no-bullet">
      <li><a href="#1">1 Overview of cl-ansi-term</a></li>
      <li><a href="#2">2 Graphic Rendition</a></li>
      <li><a href="#3">3 Primitives</a></li>
      <li><a href="#4">4 Hooks</a></li>
    </ul>
    <h2 id="1">1 Overview of cl-ansi-term</h2>
    <p>cl-ansi-term allows one to print various primitives on ANSI-complaint
      terminals. It also supports coloration and effects. cl-ansi-term is
      not like ncurses, it works with primitives that you can output on your
      terminal, as well as redirect to a file without any loss.</p>
    <p>cl-ansi-term can print the following things:</p>
    <ul>
      <li>colorized text;</li>
      <li>horizontal lines;</li>
      <li>progress bars;</li>
      <li>unordered lists;</li>
      <li>ordered lists;</li>
      <li>tables.</li>
    </ul>
    <p>cl-ansi-term uses concept of style sheet to manage coloration of
      output. You can define styles, give them names, specify foreground
      colors, background colors, and effects for every style.</p>
    <p>cl-ansi-term allows you to write your own hooks to fully control the
      library.</p>
    <p>cl-ansi-term is able to detect whether output goes to a terminal or
      to a file. If the latter case takes place, no escape sequences will
      get into the file. You can also disable all effects and coloration if
      you wish.</p>
    <p>Manual Copyright &copy; 2015 Mark Karpov.</p>
    <p>cl-ansi-term Copyright &copy; 2015 Mark Karpov.</p>
    <p>All contents here is copyright by the developers and is released
      under the <a href="http://www.gnu.org/copyleft/fdl.html"> GNU Free
      Documentation License</a>.</p>
    <p>cl-ansi-term is licensed
      under <a href="http://www.gnu.org/copyleft/gpl.html">GNU General
      Public License v.3</a>; it's free software.</p>
    <p>[<a href="#0">contents</a>]</p>
    <h2 id="2">2 Graphic Rendition</h2>
    <p>This section describes variables and functions that allow to control
      graphic rendition on ANSI-complaint terminals. cl-ansi-term uses
      concept of style sheets for graphic rendition. This means that the
      programmer doesn't need to specify all parameters every time he/she
      wants to colorize output. Instead, the programmer is provided with the
      tools to define styles of output, and then use abstract names of the
      styles to specify how output should be rendered. This allows to reduce
      repetition of rendition parameters in code and avoid associated
      errors.</p>
    <p><u>Variable</u> <code><b>*effects-enabled*</b></code></p>
    <p>If this variable is bound to non-<code>nil</code> value, graphic
      rendition effects (and other terminal-dependent effects) are enabled,
      otherwise they are disabled.</p>
    <p><u>Function</u> <code><b>update-style-sheet</b> alist</code></p>
    <p>Update style sheet used by the application. Every item
      of <code>alist</code> must be a list with <code>car</code> denoting
      name of style sheet entry and <code>cdr</code> representing collection
      of tokens that define terminal rendition. Tokens can represent various
      things: foreground color, background color, and effects. Every type of
      token has its default value, so you can omit some tokens. However, if
      there are more than one token of the same type (for
      example <code>:red</code> and <code>:green</code> - both tokens
      represent foreground color), result is unpredictable and depends on
      internal workings of Common Lisp implementation used. You cannot
      redefine <code>:default</code> style, it's always represent default
      parameters of rendition.</p>
    <p>Foreground colors are (default value is <code>:default</code>):</p>
    <ul>
      <li><code>:default</code></li>
      <li><code>:black</code></li>
      <li><code>:red</code></li>
      <li><code>:green</code></li>
      <li><code>:yellow</code></li>
      <li><code>:blue</code></li>
      <li><code>:magneta</code></li>
      <li><code>:cyan</code></li>
      <li><code>:white</code></li>
      <li><code>:black*</code></li>
      <li><code>:red*</code></li>
      <li><code>:green*</code></li>
      <li><code>:yellow*</code></li>
      <li><code>:blue*</code></li>
      <li><code>:magneta*</code></li>
      <li><code>:cyan*</code></li>
      <li><code>:white*</code></li>
    </ul>
    <p>Colors that are denoted by keywords ending with asterisk are not in
      ANSI standard (high intensity variants of 8 basic colors).</p>
    <p>Background colors are (default value is <code>:b-default</code>):</p>
    <ul>
      <li><code>:b-default</code></li>
      <li><code>:b-black</code></li>
      <li><code>:b-red</code></li>
      <li><code>:b-green</code></li>
      <li><code>:b-yellow</code></li>
      <li><code>:b-blue</code></li>
      <li><code>:b-magneta</code></li>
      <li><code>:b-cyan</code></li>
      <li><code>:b-white</code></li>
      <li><code>:b-black*</code></li>
      <li><code>:b-red*</code></li>
      <li><code>:b-green*</code></li>
      <li><code>:b-yellow*</code></li>
      <li><code>:b-blue*</code></li>
      <li><code>:b-magneta*</code></li>
      <li><code>:b-cyan*</code></li>
      <li><code>:b-white*</code></li>
    </ul>
    <p>Colors that are denoted by keywords ending with asterisk are not in
      ANSI standard (high intensity variants of 8 basic colors).</p>
    <p>Effects are (default value is <code>:normal</code>):</p>
    <ul>
      <li><code>:bold</code> &ndash; bold or increased intensity</li>
      <li><code>:faint</code> &ndash; decreased intensity (not widely
        supported)</li>
      <li><code>:italic</code> &ndash; not widely supported, sometimes
        treated as inverse</li>
      <li><code>:underline</code> &ndash; single underline</li>
      <li><code>:blink</code> &ndash; less than 150 per minute</li>
      <li><code>:bad-blink</code> &ndash; MS-DOS ANSI.SYS, 150+ per minute,
        not widely supported</li>
      <li><code>:inverse</code> &ndash; swap foreground and background
        colors, reverse video</li>
      <li><code>:hide</code> &ndash; not widely supported</li>
      <li><code>:fraktur</code> &ndash; hardly ever supported</li>
      <li><code>:normal</code> &ndash; normal color and intensity</li>
      <li><code>:framed</code></li>
      <li><code>:encircled</code></li>
      <li><code>:overlined</code></li>
    </ul>
    <p>Here is an example of <code>update-style-sheet</code> function:</p>
    <pre>(update-style-sheet
 '((:header :cyan   :underline)
   (:mark   :red    :reverse)
   (:term   :yellow :bold)))</pre>
    <p>[<a href="#0">contents</a>]</p>
    <h2 id="3">3 Primitives</h2>
    <p>This section describes a variable and functions to print various
      primitives on ANSI-complaint terminals. All the functions take many
      keyword parameters so the programmer has great control over them.</p>
    <p><u>Variable</u> <code><b>*termianl-width*</b></code></p>
    <p>Many functions use this value to output text nicely. Default value is
      <code>80</code>. If you want to dynamically change this value, write
      and register <code>:before-printing</code> hook and reassign terminal
      width before printing takes place.</p>
    <p><u>Function</u> <code><b>cat-print</b> &amp;key base-style margin
        fill-column align stream</code></p>
    <p>Concatenate <code>objects</code> and print them. <code>objects</code>
      must be a list designator that consists of printable objects and lists
      where <code>car</code> is a printable object and <code>cadr</code> is
      a keyword that denotes style of the object. Unspecified styles default
      to <code>base-style</code>. <code>margin</code>, <code>fill-column</code>,
      and <code>align</code> control corresponding parameters of
      output. Valid values for <code>align</code> are <code>:left</code>
      (default), <code>:center</code>, and <code>:right</code>. Output goes
      to <code>stream</code>.</p>
    <p><u>Function</u> <code><b>hr</b> &amp;key filler style width align
        stream</code></p>
    <p>Print a horizontal line. Characters in the line are created by
      repeating given <code>filler</code> until <code>width</code>
      characters accumulated. If <code>width</code> is not a positive
      number, <code>*terminal-width*</code> will be added to it to get
      positive <code>width</code>. <code>style</code> controls graphic
      rendition. <code>align</code> should be a
      keyword: <code>:left</code>, <code>:right</code>,
      or <code>:center</code>. Output goes to <code>stream</code>.</p>
    <p><u>Function</u> <code><b>progress-bar</b> label progress &amp;key
        margin label-style filler bar-style num-style bar-width
        stream</code></p>
    <p>Print a progress bar. If <code>progress</code> is less
      than <code>100</code>, move cursor to the beginning of current line,
      so next invocation of <code>progress-bar</code> will rewrite it. This
      function doesn't print anything if <code>progress</code> is less than
      <code>100</code> and output stream is not interactive
      or <code>*effects-enabled*</code>
      is <code>nil</code>. Insert <code>margin</code> spaces,
      then <code>label</code> (style for the label is set with
      <code>label-style</code>). Size of progress bar is set by
      <code>bar-width</code>. If <code>bar-width</code> is not a positive
      number, <code>*terminal-width*</code> will be added to it to get
      positive <code>bar-width</code>. <code>bar-style</code> is the style
      that will be used for the bar itself, while <code>num-style</code>
      will be used for number of percents and some additional
      elements. Output goes to <code>stream</code>.</p>
    <p><u>Function</u> <code><b>u-list</b> tree &amp;key bullet mark-suffix
        bullet-style item-style mark-style margin level-margin fill-column
        stream</code></p>
    <p>Print an unordered list according to <code>tree</code>. If we
      consider <code>tree</code> a list, every element must be either a
      printable object to print as a list item or a list
      where <code>car</code> is the list item and <code>cdr</code> is
      sublist of the item. <code>bullet</code> must be a string designator,
      it will be converted to string if needed and its characters will be
      used as bullets: zeroth character will be the bullet for top level of
      the list, first character is the bullet for sublist, etc. If there are
      more levels of nesting than characters in the string, it will be
      cycled. <code>bullet-style</code> is used for bullets. It can be also
      a list, in this case it's possible to specify different styles for
      different levels of nesting. <code>item-style</code> is used to render
      the list items. <code>mark-style</code> is used for items that end
      with <code>mark-suffix</code> (it can be any printable
      object). <code>level-margin</code> must be a positive integer that
      specifies how to increase margin for every level of nesting, you can
      also use plain <code>margin</code>. <code>fill-column</code> is used
      to split long items, if it's not a positive
      number, <code>*terminal-width*</code> will be added to it to get
      positive <code>fill-column</code>. Output goes
      to <code>stream</code>.</p>
    <p><u>Function</u> <code><b>o-list</b> tree &amp;key index delimiter
        mark-suffix index-style item-style mark-style margin level-margin
        fill-column stream</code></p>
    <p>Print ordered list according to <code>tree</code>. If we consider
      <code>tree</code> a list, every element must be either a printable
      object to print as a list item or a list where <code>car</code> is
      list item and <code>cdr</code> is sublist of the
      item. <code>index</code> must be a list designator, its elements
      should be keywords that denote how to represent numeration. Acceptable
      values are:</p>
    <ul>
      <li><code>:arabic</code> &ndash; indexes will be printed as arabic
        numerals (default value)</li>
      <li><code>:roman</code> &ndash; indexes will be printed as roman
        numerals</li>
      <li><code>:letter</code> &ndash; indexes will be printed as letters of
        Latin alphabet</li>
      <li><code>:capital</code> &ndash; the same as <code>:letter</code>,
        but capital letters are used</li>
    </ul>
    <p>If there are more levels of nesting than elements in the list, it
      will be cycled. The same applies to <code>delimiter</code>, which must
      be a string designator. <code>index-style</code> is used for
      indexes. It can be also list, in this case it's possible to specify
      different styles for different levels of
      nesting. <code>item-style</code> is used to render the list
      items. <code>mark-style</code> is used for items that end with
      <code>mark-suffix</code> (it can be any printable
      object). <code>level-margin</code> must be a positive integer that
      specifies how to increase margin for every level of nesting, you can
      also use plain <code>margin</code>. <code>fill-column</code> is used
      to split long items, if it's not a positive
      number, <code>*terminal-output*</code> will be added to it to get
      positive <code>fill-column</code>. Output goes
      to <code>stream</code>.</p>
    <p><u>Function</u> <code><b>table</b> objects &amp;key mark-suffix
        border-chars border-style header-style cell-style mark-style
        col-header margin column-width align stream</code></p>
    <p>Print a table filling cells
      with <code>objects</code>. <code>objects</code> must be a list of list
      designators. If <code>border-style</code> is <code>nil</code>, no
      border will be printed, otherwise <code>border-style</code> is
      expected to be a keyword that denotes style in which borders of the
      table should be printed. <code>header-style</code> will be applied to
      the first row of the table (also to the first column
      if <code>col-header</code> is not <code>nil</code>)
      and <code>cell-style</code> will be applied to all other rows. Objects
      that end with <code>mark-suffix</code> will be printed using
      <code>mark-style</code>. <code>margin</code>, <code>column-width</code>,
      and <code>align</code> can also be specified. Valid values
      of <code>align</code> are: <code>:left</code> (default
      value), <code>:center</code>, and <code>:right</code>. Output goes to
      <code>stream</code>.</p>
    <p>[<a href="#0">contents</a>]</p>
    <h2 id="4">4 Hooks</h2>
    <p>The section describes functions that allow to register custom hooks
      that will be invoked on specific pre-defined events.</p>
    <p><u>Function</u> <code><b>register-hook</b> event function</code></p>
    <p>Register a hook. When predefined <code>event</code>
      occurs <code>function</code> will be called. You can register many functions
      to call on the same event.</p>
    <p>Acceptable values of <code>event</code>:</p>
    <ul>
      <li><code>:before-printing</code> &ndash; <code>function</code> is
        invoked just before printing takes place, no argument is passed to
        the function</li>
      <li><code>:after-printing</code> &ndash; <code>function</code> is
        invoked after printing, no argument is passed to the function</li>
      <li><code>:on-style-change</code> - <code>function</code> is invoked
        before style changing escape sequence in printed. One argument is
        passed to <code>function</code>, name of the style, which is a
        keyword</li>
    </ul>
    <p><u>Function</u> <code><b>remove-hook</b> event</code></p>
    <p>Remove all registered functions that are called
      on <code>event</code>. Returns <code>t</code> if there were any
      functions associated with <code>event</code> and <code>nil</code>
      otherwise.</p>
    <p>[<a href="#0">contents</a>]</p>
  </body>
</html>
